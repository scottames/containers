// Code generated by dagger. DO NOT EDIT.

package main

import (
	"context"
	"encoding/json"
	"fmt"
	"log/slog"
	"os"

	"dagger/atomic/internal/dagger"
	"dagger/atomic/internal/telemetry"

	"go.opentelemetry.io/otel"
	"go.opentelemetry.io/otel/sdk/resource"
	semconv "go.opentelemetry.io/otel/semconv/v1.4.0"
	"go.opentelemetry.io/otel/trace"
)

var dag = dagger.Connect()

func Tracer() trace.Tracer {
	return otel.Tracer("dagger.io/sdk.go")
}

// used for local MarshalJSON implementations
var marshalCtx = context.Background()

// called by main()
func setMarshalContext(ctx context.Context) {
	marshalCtx = ctx
	dagger.SetMarshalContext(ctx)
}

type DaggerObject = dagger.DaggerObject

type ExecError = dagger.ExecError

// The `CacheVolumeID` scalar type represents an identifier for an object of type CacheVolume.
type CacheVolumeID = dagger.CacheVolumeID

// The `ContainerID` scalar type represents an identifier for an object of type Container.
type ContainerID = dagger.ContainerID

// The `CosignID` scalar type represents an identifier for an object of type Cosign.
type CosignID = dagger.CosignID

// The `CurrentModuleID` scalar type represents an identifier for an object of type CurrentModule.
type CurrentModuleID = dagger.CurrentModuleID

// The `DirectoryID` scalar type represents an identifier for an object of type Directory.
type DirectoryID = dagger.DirectoryID

// The `EnvVariableID` scalar type represents an identifier for an object of type EnvVariable.
type EnvVariableID = dagger.EnvVariableID

// The `FedoraContainerLabelID` scalar type represents an identifier for an object of type FedoraContainerLabel.
type FedoraContainerLabelID = dagger.FedoraContainerLabelID

// The `FedoraDirectoryFromSourceID` scalar type represents an identifier for an object of type FedoraDirectoryFromSource.
type FedoraDirectoryFromSourceID = dagger.FedoraDirectoryFromSourceID

// The `FedoraFileFromSourceID` scalar type represents an identifier for an object of type FedoraFileFromSource.
type FedoraFileFromSourceID = dagger.FedoraFileFromSourceID

// The `FedoraID` scalar type represents an identifier for an object of type Fedora.
type FedoraID = dagger.FedoraID

// The `FedoraRepoID` scalar type represents an identifier for an object of type FedoraRepo.
type FedoraRepoID = dagger.FedoraRepoID

// The `FedoraSwapID` scalar type represents an identifier for an object of type FedoraSwap.
type FedoraSwapID = dagger.FedoraSwapID

// The `FieldTypeDefID` scalar type represents an identifier for an object of type FieldTypeDef.
type FieldTypeDefID = dagger.FieldTypeDefID

// The `FileID` scalar type represents an identifier for an object of type File.
type FileID = dagger.FileID

// The `FunctionArgID` scalar type represents an identifier for an object of type FunctionArg.
type FunctionArgID = dagger.FunctionArgID

// The `FunctionCallArgValueID` scalar type represents an identifier for an object of type FunctionCallArgValue.
type FunctionCallArgValueID = dagger.FunctionCallArgValueID

// The `FunctionCallID` scalar type represents an identifier for an object of type FunctionCall.
type FunctionCallID = dagger.FunctionCallID

// The `FunctionID` scalar type represents an identifier for an object of type Function.
type FunctionID = dagger.FunctionID

// The `GeneratedCodeID` scalar type represents an identifier for an object of type GeneratedCode.
type GeneratedCodeID = dagger.GeneratedCodeID

// The `GitModuleSourceID` scalar type represents an identifier for an object of type GitModuleSource.
type GitModuleSourceID = dagger.GitModuleSourceID

// The `GitRefID` scalar type represents an identifier for an object of type GitRef.
type GitRefID = dagger.GitRefID

// The `GitRepositoryID` scalar type represents an identifier for an object of type GitRepository.
type GitRepositoryID = dagger.GitRepositoryID

// The `InputTypeDefID` scalar type represents an identifier for an object of type InputTypeDef.
type InputTypeDefID = dagger.InputTypeDefID

// The `InterfaceTypeDefID` scalar type represents an identifier for an object of type InterfaceTypeDef.
type InterfaceTypeDefID = dagger.InterfaceTypeDefID

// An arbitrary JSON-encoded value.
type JSON = dagger.JSON

// The `LabelID` scalar type represents an identifier for an object of type Label.
type LabelID = dagger.LabelID

// The `ListTypeDefID` scalar type represents an identifier for an object of type ListTypeDef.
type ListTypeDefID = dagger.ListTypeDefID

// The `LocalModuleSourceID` scalar type represents an identifier for an object of type LocalModuleSource.
type LocalModuleSourceID = dagger.LocalModuleSourceID

// The `ModuleDependencyID` scalar type represents an identifier for an object of type ModuleDependency.
type ModuleDependencyID = dagger.ModuleDependencyID

// The `ModuleID` scalar type represents an identifier for an object of type Module.
type ModuleID = dagger.ModuleID

// The `ModuleSourceID` scalar type represents an identifier for an object of type ModuleSource.
type ModuleSourceID = dagger.ModuleSourceID

// The `ModuleSourceViewID` scalar type represents an identifier for an object of type ModuleSourceView.
type ModuleSourceViewID = dagger.ModuleSourceViewID

// The `ObjectTypeDefID` scalar type represents an identifier for an object of type ObjectTypeDef.
type ObjectTypeDefID = dagger.ObjectTypeDefID

// The platform config OS and architecture in a Container.
//
// The format is [os]/[platform]/[version] (e.g., "darwin/arm64/v7", "windows/amd64", "linux/arm64").
type Platform = dagger.Platform

// The `PortID` scalar type represents an identifier for an object of type Port.
type PortID = dagger.PortID

// The `ScalarTypeDefID` scalar type represents an identifier for an object of type ScalarTypeDef.
type ScalarTypeDefID = dagger.ScalarTypeDefID

// The `SecretID` scalar type represents an identifier for an object of type Secret.
type SecretID = dagger.SecretID

// The `ServiceID` scalar type represents an identifier for an object of type Service.
type ServiceID = dagger.ServiceID

// The `SocketID` scalar type represents an identifier for an object of type Socket.
type SocketID = dagger.SocketID

// The `TerminalID` scalar type represents an identifier for an object of type Terminal.
type TerminalID = dagger.TerminalID

// The `TypeDefID` scalar type represents an identifier for an object of type TypeDef.
type TypeDefID = dagger.TypeDefID

// The absence of a value.
//
// A Null Void is used as a placeholder for resolvers that do not return anything.
type Void = dagger.Void

// Key value object that represents a build argument.
type BuildArg = dagger.BuildArg

// Key value object that represents a pipeline label.
type PipelineLabel = dagger.PipelineLabel

// Port forwarding rules for tunneling network traffic.
type PortForward = dagger.PortForward

// A directory whose contents persist across runs.
type CacheVolume = dagger.CacheVolume

// An OCI-compatible container, also known as a Docker container.
type Container = dagger.Container

type WithContainerFunc = dagger.WithContainerFunc

// ContainerAsTarballOpts contains options for Container.AsTarball
type ContainerAsTarballOpts = dagger.ContainerAsTarballOpts

// ContainerBuildOpts contains options for Container.Build
type ContainerBuildOpts = dagger.ContainerBuildOpts

// ContainerExportOpts contains options for Container.Export
type ContainerExportOpts = dagger.ContainerExportOpts

// ContainerImportOpts contains options for Container.Import
type ContainerImportOpts = dagger.ContainerImportOpts

// ContainerPipelineOpts contains options for Container.Pipeline
type ContainerPipelineOpts = dagger.ContainerPipelineOpts

// ContainerPublishOpts contains options for Container.Publish
type ContainerPublishOpts = dagger.ContainerPublishOpts

// ContainerTerminalOpts contains options for Container.Terminal
type ContainerTerminalOpts = dagger.ContainerTerminalOpts

// ContainerWithDefaultTerminalCmdOpts contains options for Container.WithDefaultTerminalCmd
type ContainerWithDefaultTerminalCmdOpts = dagger.ContainerWithDefaultTerminalCmdOpts

// ContainerWithDirectoryOpts contains options for Container.WithDirectory
type ContainerWithDirectoryOpts = dagger.ContainerWithDirectoryOpts

// ContainerWithEntrypointOpts contains options for Container.WithEntrypoint
type ContainerWithEntrypointOpts = dagger.ContainerWithEntrypointOpts

// ContainerWithEnvVariableOpts contains options for Container.WithEnvVariable
type ContainerWithEnvVariableOpts = dagger.ContainerWithEnvVariableOpts

// ContainerWithExecOpts contains options for Container.WithExec
type ContainerWithExecOpts = dagger.ContainerWithExecOpts

// ContainerWithExposedPortOpts contains options for Container.WithExposedPort
type ContainerWithExposedPortOpts = dagger.ContainerWithExposedPortOpts

// ContainerWithFileOpts contains options for Container.WithFile
type ContainerWithFileOpts = dagger.ContainerWithFileOpts

// ContainerWithFilesOpts contains options for Container.WithFiles
type ContainerWithFilesOpts = dagger.ContainerWithFilesOpts

// ContainerWithMountedCacheOpts contains options for Container.WithMountedCache
type ContainerWithMountedCacheOpts = dagger.ContainerWithMountedCacheOpts

// ContainerWithMountedDirectoryOpts contains options for Container.WithMountedDirectory
type ContainerWithMountedDirectoryOpts = dagger.ContainerWithMountedDirectoryOpts

// ContainerWithMountedFileOpts contains options for Container.WithMountedFile
type ContainerWithMountedFileOpts = dagger.ContainerWithMountedFileOpts

// ContainerWithMountedSecretOpts contains options for Container.WithMountedSecret
type ContainerWithMountedSecretOpts = dagger.ContainerWithMountedSecretOpts

// ContainerWithNewFileOpts contains options for Container.WithNewFile
type ContainerWithNewFileOpts = dagger.ContainerWithNewFileOpts

// ContainerWithUnixSocketOpts contains options for Container.WithUnixSocket
type ContainerWithUnixSocketOpts = dagger.ContainerWithUnixSocketOpts

// ContainerWithoutEntrypointOpts contains options for Container.WithoutEntrypoint
type ContainerWithoutEntrypointOpts = dagger.ContainerWithoutEntrypointOpts

// ContainerWithoutExposedPortOpts contains options for Container.WithoutExposedPort
type ContainerWithoutExposedPortOpts = dagger.ContainerWithoutExposedPortOpts

// Cosign represents the cosign Dagger module type
type Cosign = dagger.Cosign

// CosignSignOpts contains options for Cosign.Sign
type CosignSignOpts = dagger.CosignSignOpts

// Reflective module API provided to functions at runtime.
type CurrentModule = dagger.CurrentModule

// CurrentModuleWorkdirOpts contains options for CurrentModule.Workdir
type CurrentModuleWorkdirOpts = dagger.CurrentModuleWorkdirOpts

// A directory.
type Directory = dagger.Directory

type WithDirectoryFunc = dagger.WithDirectoryFunc

// DirectoryAsModuleOpts contains options for Directory.AsModule
type DirectoryAsModuleOpts = dagger.DirectoryAsModuleOpts

// DirectoryDockerBuildOpts contains options for Directory.DockerBuild
type DirectoryDockerBuildOpts = dagger.DirectoryDockerBuildOpts

// DirectoryEntriesOpts contains options for Directory.Entries
type DirectoryEntriesOpts = dagger.DirectoryEntriesOpts

// DirectoryExportOpts contains options for Directory.Export
type DirectoryExportOpts = dagger.DirectoryExportOpts

// DirectoryPipelineOpts contains options for Directory.Pipeline
type DirectoryPipelineOpts = dagger.DirectoryPipelineOpts

// DirectoryWithDirectoryOpts contains options for Directory.WithDirectory
type DirectoryWithDirectoryOpts = dagger.DirectoryWithDirectoryOpts

// DirectoryWithFileOpts contains options for Directory.WithFile
type DirectoryWithFileOpts = dagger.DirectoryWithFileOpts

// DirectoryWithFilesOpts contains options for Directory.WithFiles
type DirectoryWithFilesOpts = dagger.DirectoryWithFilesOpts

// DirectoryWithNewDirectoryOpts contains options for Directory.WithNewDirectory
type DirectoryWithNewDirectoryOpts = dagger.DirectoryWithNewDirectoryOpts

// DirectoryWithNewFileOpts contains options for Directory.WithNewFile
type DirectoryWithNewFileOpts = dagger.DirectoryWithNewFileOpts

// An environment variable name and value.
type EnvVariable = dagger.EnvVariable

// Fedora represents the constructed Fedora image
type Fedora = dagger.Fedora

type WithFedoraFunc = dagger.WithFedoraFunc

// FedoraContainerAddressOpts contains options for Fedora.ContainerAddress
type FedoraContainerAddressOpts = dagger.FedoraContainerAddressOpts

// FedoraContainerReleaseVersionFromLabelOpts contains options for Fedora.ContainerReleaseVersionFromLabel
type FedoraContainerReleaseVersionFromLabelOpts = dagger.FedoraContainerReleaseVersionFromLabelOpts

// FedoraContainerVersionFromLabelOpts contains options for Fedora.ContainerVersionFromLabel
type FedoraContainerVersionFromLabelOpts = dagger.FedoraContainerVersionFromLabelOpts

// FedoraDefaultTagsOpts contains options for Fedora.DefaultTags
type FedoraDefaultTagsOpts = dagger.FedoraDefaultTagsOpts

// ContainerLabel represents a Label to be placed in the generated Container
// image at the Destination
type FedoraContainerLabel = dagger.FedoraContainerLabel

// DirectoryFromSource represents a Directory to be placed in the generated
// Container image at the Destination
type FedoraDirectoryFromSource = dagger.FedoraDirectoryFromSource

// FileFromSource represents a File to be placed in the generated Container
// image at the Destination
type FedoraFileFromSource = dagger.FedoraFileFromSource

// Repo represents a yum repository object
type FedoraRepo = dagger.FedoraRepo

type FedoraSwap = dagger.FedoraSwap

// A definition of a field on a custom object defined in a Module.
//
// A field on an object has a static value, as opposed to a function on an object whose value is computed by invoking code (and can accept arguments).
type FieldTypeDef = dagger.FieldTypeDef

// A file.
type File = dagger.File

type WithFileFunc = dagger.WithFileFunc

// FileExportOpts contains options for File.Export
type FileExportOpts = dagger.FileExportOpts

// Function represents a resolver provided by a Module.
//
// A function always evaluates against a parent object and is given a set of named arguments.
type Function = dagger.Function

type WithFunctionFunc = dagger.WithFunctionFunc

// FunctionWithArgOpts contains options for Function.WithArg
type FunctionWithArgOpts = dagger.FunctionWithArgOpts

// An argument accepted by a function.
//
// This is a specification for an argument at function definition time, not an argument passed at function call time.
type FunctionArg = dagger.FunctionArg

// An active function call.
type FunctionCall = dagger.FunctionCall

// A value passed as a named argument to a function call.
type FunctionCallArgValue = dagger.FunctionCallArgValue

// The result of running an SDK's codegen.
type GeneratedCode = dagger.GeneratedCode

type WithGeneratedCodeFunc = dagger.WithGeneratedCodeFunc

// Module source originating from a git repo.
type GitModuleSource = dagger.GitModuleSource

// A git ref (tag, branch, or commit).
type GitRef = dagger.GitRef

// GitRefTreeOpts contains options for GitRef.Tree
type GitRefTreeOpts = dagger.GitRefTreeOpts

// A git repository.
type GitRepository = dagger.GitRepository

type WithGitRepositoryFunc = dagger.WithGitRepositoryFunc

// A graphql input type, which is essentially just a group of named args.
// This is currently only used to represent pre-existing usage of graphql input types
// in the core API. It is not used by user modules and shouldn't ever be as user
// module accept input objects via their id rather than graphql input types.
type InputTypeDef = dagger.InputTypeDef

// A definition of a custom interface defined in a Module.
type InterfaceTypeDef = dagger.InterfaceTypeDef

// A simple key value object that represents a label.
type Label = dagger.Label

// A definition of a list type in a Module.
type ListTypeDef = dagger.ListTypeDef

// Module source that that originates from a path locally relative to an arbitrary directory.
type LocalModuleSource = dagger.LocalModuleSource

// A Dagger module.
type Module = dagger.Module

type WithModuleFunc = dagger.WithModuleFunc

// The configuration of dependency of a module.
type ModuleDependency = dagger.ModuleDependency

// The source needed to load and run a module, along with any metadata about the source such as versions/urls/etc.
type ModuleSource = dagger.ModuleSource

type WithModuleSourceFunc = dagger.WithModuleSourceFunc

// ModuleSourceResolveDirectoryFromCallerOpts contains options for ModuleSource.ResolveDirectoryFromCaller
type ModuleSourceResolveDirectoryFromCallerOpts = dagger.ModuleSourceResolveDirectoryFromCallerOpts

// A named set of path filters that can be applied to directory arguments provided to functions.
type ModuleSourceView = dagger.ModuleSourceView

// A definition of a custom object defined in a Module.
type ObjectTypeDef = dagger.ObjectTypeDef

// A port exposed by a container.
type Port = dagger.Port

// The root of the DAG.
type Client = dagger.Client

type WithClientFunc = dagger.WithClientFunc

// ContainerOpts contains options for Client.Container
type ContainerOpts = dagger.ContainerOpts

// DirectoryOpts contains options for Client.Directory
type DirectoryOpts = dagger.DirectoryOpts

// FedoraOpts contains options for Client.Fedora
type FedoraOpts = dagger.FedoraOpts

// GitOpts contains options for Client.Git
type GitOpts = dagger.GitOpts

// HTTPOpts contains options for Client.HTTP
type HTTPOpts = dagger.HTTPOpts

// ModuleDependencyOpts contains options for Client.ModuleDependency
type ModuleDependencyOpts = dagger.ModuleDependencyOpts

// ModuleSourceOpts contains options for Client.ModuleSource
type ModuleSourceOpts = dagger.ModuleSourceOpts

// PipelineOpts contains options for Client.Pipeline
type PipelineOpts = dagger.PipelineOpts

// SecretOpts contains options for Client.Secret
type SecretOpts = dagger.SecretOpts

// A definition of a custom scalar defined in a Module.
type ScalarTypeDef = dagger.ScalarTypeDef

// A reference to a secret value, which can be handled more safely than the value itself.
type Secret = dagger.Secret

// A content-addressed service providing TCP connectivity.
type Service = dagger.Service

// ServiceEndpointOpts contains options for Service.Endpoint
type ServiceEndpointOpts = dagger.ServiceEndpointOpts

// ServiceStopOpts contains options for Service.Stop
type ServiceStopOpts = dagger.ServiceStopOpts

// ServiceUpOpts contains options for Service.Up
type ServiceUpOpts = dagger.ServiceUpOpts

// A Unix or TCP/IP socket that can be mounted into a container.
type Socket = dagger.Socket

// An interactive terminal that clients can connect to.
type Terminal = dagger.Terminal

// A definition of a parameter or return type in a Module.
type TypeDef = dagger.TypeDef

type WithTypeDefFunc = dagger.WithTypeDefFunc

// TypeDefWithFieldOpts contains options for TypeDef.WithField
type TypeDefWithFieldOpts = dagger.TypeDefWithFieldOpts

// TypeDefWithInterfaceOpts contains options for TypeDef.WithInterface
type TypeDefWithInterfaceOpts = dagger.TypeDefWithInterfaceOpts

// TypeDefWithObjectOpts contains options for TypeDef.WithObject
type TypeDefWithObjectOpts = dagger.TypeDefWithObjectOpts

// TypeDefWithScalarOpts contains options for TypeDef.WithScalar
type TypeDefWithScalarOpts = dagger.TypeDefWithScalarOpts

// Sharing mode of the cache volume.
type CacheSharingMode = dagger.CacheSharingMode

const (
	// Shares the cache volume amongst many build pipelines, but will serialize the writes
	Locked CacheSharingMode = dagger.Locked

	// Keeps a cache volume for a single build pipeline
	Private CacheSharingMode = dagger.Private

	// Shares the cache volume amongst many build pipelines
	Shared CacheSharingMode = dagger.Shared
)

// Compression algorithm to use for image layers.
type ImageLayerCompression = dagger.ImageLayerCompression

const (
	Estargz ImageLayerCompression = dagger.Estargz

	Gzip ImageLayerCompression = dagger.Gzip

	Uncompressed ImageLayerCompression = dagger.Uncompressed

	Zstd ImageLayerCompression = dagger.Zstd
)

// Mediatypes to use in published or exported image metadata.
type ImageMediaTypes = dagger.ImageMediaTypes

const (
	Dockermediatypes ImageMediaTypes = dagger.Dockermediatypes

	Ocimediatypes ImageMediaTypes = dagger.Ocimediatypes
)

// The kind of module source.
type ModuleSourceKind = dagger.ModuleSourceKind

const (
	GitSource ModuleSourceKind = dagger.GitSource

	LocalSource ModuleSourceKind = dagger.LocalSource
)

// Transport layer network protocol associated to a port.
type NetworkProtocol = dagger.NetworkProtocol

const (
	Tcp NetworkProtocol = dagger.Tcp

	Udp NetworkProtocol = dagger.Udp
)

// Distinguishes the different kinds of TypeDefs.
type TypeDefKind = dagger.TypeDefKind

const (
	// A boolean value.
	BooleanKind TypeDefKind = dagger.BooleanKind

	// A graphql input type, used only when representing the core API via TypeDefs.
	InputKind TypeDefKind = dagger.InputKind

	// An integer value.
	IntegerKind TypeDefKind = dagger.IntegerKind

	// A named type of functions that can be matched+implemented by other objects+interfaces.
	//
	// Always paired with an InterfaceTypeDef.
	InterfaceKind TypeDefKind = dagger.InterfaceKind

	// A list of values all having the same type.
	//
	// Always paired with a ListTypeDef.
	ListKind TypeDefKind = dagger.ListKind

	// A named type defined in the GraphQL schema, with fields and functions.
	//
	// Always paired with an ObjectTypeDef.
	ObjectKind TypeDefKind = dagger.ObjectKind

	// A scalar value of any basic kind.
	ScalarKind TypeDefKind = dagger.ScalarKind

	// A string value.
	StringKind TypeDefKind = dagger.StringKind

	// A special kind used to signify that no value is returned.
	//
	// This is used for functions that have no return value. The outer TypeDef specifying this Kind is always Optional, as the Void is never actually represented.
	VoidKind TypeDefKind = dagger.VoidKind
)

// ptr returns a pointer to the given value.
func ptr[T any](v T) *T {
	return &v
}

// convertSlice converts a slice of one type to a slice of another type using a
// converter function
func convertSlice[I any, O any](in []I, f func(I) O) []O {
	out := make([]O, len(in))
	for i, v := range in {
		out[i] = f(v)
	}
	return out
}

func (r Atomic) MarshalJSON() ([]byte, error) {
	var concrete struct {
		Source            *Directory
		Registry          string
		Org               string
		Tag               string
		Variant           string
		Suffix            *string
		Digests           []string
		Labels            []string
		Tags              []string
		ReleaseVersion    string
		SkipDefaultLabels bool
	}
	concrete.Source = r.Source
	concrete.Registry = r.Registry
	concrete.Org = r.Org
	concrete.Tag = r.Tag
	concrete.Variant = r.Variant
	concrete.Suffix = r.Suffix
	concrete.Digests = r.Digests
	concrete.Labels = r.Labels
	concrete.Tags = r.Tags
	concrete.ReleaseVersion = r.ReleaseVersion
	concrete.SkipDefaultLabels = r.SkipDefaultLabels
	return json.Marshal(&concrete)
}

func (r *Atomic) UnmarshalJSON(bs []byte) error {
	var concrete struct {
		Source            *Directory
		Registry          string
		Org               string
		Tag               string
		Variant           string
		Suffix            *string
		Digests           []string
		Labels            []string
		Tags              []string
		ReleaseVersion    string
		SkipDefaultLabels bool
	}
	err := json.Unmarshal(bs, &concrete)
	if err != nil {
		return err
	}
	r.Source = concrete.Source
	r.Registry = concrete.Registry
	r.Org = concrete.Org
	r.Tag = concrete.Tag
	r.Variant = concrete.Variant
	r.Suffix = concrete.Suffix
	r.Digests = concrete.Digests
	r.Labels = concrete.Labels
	r.Tags = concrete.Tags
	r.ReleaseVersion = concrete.ReleaseVersion
	r.SkipDefaultLabels = concrete.SkipDefaultLabels
	return nil
}

func main() {
	ctx := context.Background()

	// Direct slog to the new stderr. This is only for dev time debugging, and
	// runtime errors/warnings.
	slog.SetDefault(slog.New(slog.NewTextHandler(os.Stderr, &slog.HandlerOptions{
		Level: slog.LevelWarn,
	})))

	if err := dispatch(ctx); err != nil {
		fmt.Println(err.Error())
		os.Exit(2)
	}
}

func dispatch(ctx context.Context) error {
	ctx = telemetry.InitEmbedded(ctx, resource.NewWithAttributes(
		semconv.SchemaURL,
		semconv.ServiceNameKey.String("dagger-go-sdk"),
		// TODO version?
	))
	defer telemetry.Close()

	// A lot of the "work" actually happens when we're marshalling the return
	// value, which entails getting object IDs, which happens in MarshalJSON,
	// which has no ctx argument, so we use this lovely global variable.
	setMarshalContext(ctx)

	fnCall := dag.CurrentFunctionCall()
	parentName, err := fnCall.ParentName(ctx)
	if err != nil {
		return fmt.Errorf("get parent name: %w", err)
	}
	fnName, err := fnCall.Name(ctx)
	if err != nil {
		return fmt.Errorf("get fn name: %w", err)
	}
	parentJson, err := fnCall.Parent(ctx)
	if err != nil {
		return fmt.Errorf("get fn parent: %w", err)
	}
	fnArgs, err := fnCall.InputArgs(ctx)
	if err != nil {
		return fmt.Errorf("get fn args: %w", err)
	}

	inputArgs := map[string][]byte{}
	for _, fnArg := range fnArgs {
		argName, err := fnArg.Name(ctx)
		if err != nil {
			return fmt.Errorf("get fn arg name: %w", err)
		}
		argValue, err := fnArg.Value(ctx)
		if err != nil {
			return fmt.Errorf("get fn arg value: %w", err)
		}
		inputArgs[argName] = []byte(argValue)
	}

	result, err := invoke(ctx, []byte(parentJson), parentName, fnName, inputArgs)
	if err != nil {
		return fmt.Errorf("invoke: %w", err)
	}
	resultBytes, err := json.Marshal(result)
	if err != nil {
		return fmt.Errorf("marshal: %w", err)
	}
	_, err = fnCall.ReturnValue(ctx, JSON(resultBytes))
	if err != nil {
		return fmt.Errorf("store return value: %w", err)
	}
	return nil
}

func invoke(ctx context.Context, parentJSON []byte, parentName string, fnName string, inputArgs map[string][]byte) (_ any, err error) {
	_ = inputArgs
	switch parentName {
	case "Atomic":
		switch fnName {
		case "Container":
			var parent Atomic
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			return (*Atomic).Container(&parent, ctx)
		case "Publish":
			var parent Atomic
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var registry string
			if inputArgs["registry"] != nil {
				err = json.Unmarshal([]byte(inputArgs["registry"]), &registry)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg registry", err))
				}
			}
			var imageName string
			if inputArgs["imageName"] != nil {
				err = json.Unmarshal([]byte(inputArgs["imageName"]), &imageName)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg imageName", err))
				}
			}
			var additionalTags []string
			if inputArgs["additionalTags"] != nil {
				err = json.Unmarshal([]byte(inputArgs["additionalTags"]), &additionalTags)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg additionalTags", err))
				}
			}
			var username string
			if inputArgs["username"] != nil {
				err = json.Unmarshal([]byte(inputArgs["username"]), &username)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg username", err))
				}
			}
			var secret *Secret
			if inputArgs["secret"] != nil {
				err = json.Unmarshal([]byte(inputArgs["secret"]), &secret)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg secret", err))
				}
			}
			var skipSigningConfig bool
			if inputArgs["skipSigningConfig"] != nil {
				err = json.Unmarshal([]byte(inputArgs["skipSigningConfig"]), &skipSigningConfig)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg skipSigningConfig", err))
				}
			}
			var skipRegistryNamespace bool
			if inputArgs["skipRegistryNamespace"] != nil {
				err = json.Unmarshal([]byte(inputArgs["skipRegistryNamespace"]), &skipRegistryNamespace)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg skipRegistryNamespace", err))
				}
			}
			var skipDefaultTags bool
			if inputArgs["skipDefaultTags"] != nil {
				err = json.Unmarshal([]byte(inputArgs["skipDefaultTags"]), &skipDefaultTags)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg skipDefaultTags", err))
				}
			}
			return (*Atomic).Publish(&parent, ctx, registry, imageName, additionalTags, username, secret, skipSigningConfig, skipRegistryNamespace, skipDefaultTags)
		case "PublishAndSign":
			var parent Atomic
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var registry string
			if inputArgs["registry"] != nil {
				err = json.Unmarshal([]byte(inputArgs["registry"]), &registry)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg registry", err))
				}
			}
			var imageName string
			if inputArgs["imageName"] != nil {
				err = json.Unmarshal([]byte(inputArgs["imageName"]), &imageName)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg imageName", err))
				}
			}
			var additionalTags []string
			if inputArgs["additionalTags"] != nil {
				err = json.Unmarshal([]byte(inputArgs["additionalTags"]), &additionalTags)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg additionalTags", err))
				}
			}
			var username string
			if inputArgs["username"] != nil {
				err = json.Unmarshal([]byte(inputArgs["username"]), &username)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg username", err))
				}
			}
			var secret *Secret
			if inputArgs["secret"] != nil {
				err = json.Unmarshal([]byte(inputArgs["secret"]), &secret)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg secret", err))
				}
			}
			var skipSigningConfig bool
			if inputArgs["skipSigningConfig"] != nil {
				err = json.Unmarshal([]byte(inputArgs["skipSigningConfig"]), &skipSigningConfig)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg skipSigningConfig", err))
				}
			}
			var skipRegistryNamespace bool
			if inputArgs["skipRegistryNamespace"] != nil {
				err = json.Unmarshal([]byte(inputArgs["skipRegistryNamespace"]), &skipRegistryNamespace)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg skipRegistryNamespace", err))
				}
			}
			var skipDefaultTags bool
			if inputArgs["skipDefaultTags"] != nil {
				err = json.Unmarshal([]byte(inputArgs["skipDefaultTags"]), &skipDefaultTags)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg skipDefaultTags", err))
				}
			}
			var cosignPrivateKey Secret
			if inputArgs["cosignPrivateKey"] != nil {
				err = json.Unmarshal([]byte(inputArgs["cosignPrivateKey"]), &cosignPrivateKey)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg cosignPrivateKey", err))
				}
			}
			var cosignPassword Secret
			if inputArgs["cosignPassword"] != nil {
				err = json.Unmarshal([]byte(inputArgs["cosignPassword"]), &cosignPassword)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg cosignPassword", err))
				}
			}
			var dockerConfig *File
			if inputArgs["dockerConfig"] != nil {
				err = json.Unmarshal([]byte(inputArgs["dockerConfig"]), &dockerConfig)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg dockerConfig", err))
				}
			}
			var cosignImage *string
			if inputArgs["cosignImage"] != nil {
				err = json.Unmarshal([]byte(inputArgs["cosignImage"]), &cosignImage)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg cosignImage", err))
				}
			}
			var cosignUser *string
			if inputArgs["cosignUser"] != nil {
				err = json.Unmarshal([]byte(inputArgs["cosignUser"]), &cosignUser)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg cosignUser", err))
				}
			}
			return (*Atomic).PublishAndSign(&parent, ctx, registry, imageName, additionalTags, username, secret, skipSigningConfig, skipRegistryNamespace, skipDefaultTags, cosignPrivateKey, cosignPassword, dockerConfig, cosignImage, cosignUser)
		case "":
			var parent Atomic
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var source *Directory
			if inputArgs["source"] != nil {
				err = json.Unmarshal([]byte(inputArgs["source"]), &source)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg source", err))
				}
			}
			var registry string
			if inputArgs["registry"] != nil {
				err = json.Unmarshal([]byte(inputArgs["registry"]), &registry)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg registry", err))
				}
			}
			var org string
			if inputArgs["org"] != nil {
				err = json.Unmarshal([]byte(inputArgs["org"]), &org)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg org", err))
				}
			}
			var variant string
			if inputArgs["variant"] != nil {
				err = json.Unmarshal([]byte(inputArgs["variant"]), &variant)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg variant", err))
				}
			}
			var suffix *string
			if inputArgs["suffix"] != nil {
				err = json.Unmarshal([]byte(inputArgs["suffix"]), &suffix)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg suffix", err))
				}
			}
			var tag string
			if inputArgs["tag"] != nil {
				err = json.Unmarshal([]byte(inputArgs["tag"]), &tag)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg tag", err))
				}
			}
			var additionalLabels []string
			if inputArgs["additionalLabels"] != nil {
				err = json.Unmarshal([]byte(inputArgs["additionalLabels"]), &additionalLabels)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg additionalLabels", err))
				}
			}
			var skipDefaultLabels bool
			if inputArgs["skipDefaultLabels"] != nil {
				err = json.Unmarshal([]byte(inputArgs["skipDefaultLabels"]), &skipDefaultLabels)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg skipDefaultLabels", err))
				}
			}
			return New(ctx, source, registry, org, variant, suffix, tag, additionalLabels, skipDefaultLabels)
		default:
			return nil, fmt.Errorf("unknown function %s", fnName)
		}
	case "":
		return dag.Module().
			WithDescription("# Fedora Atomic\n\nA custom Fedora Atomic container image dagger module heavily customized for\nmy personal use.\n\nNOTE:\nInterested in making your own? Create an issue, we can work\ntogether to build a proper template. Or just fork and yolo!\n\nThe heavy lifting behind Fedora Atomic images is done by the Fedora and\nUniversal Blue communities.\n\n- Fedora Atomic: https://fedoraproject.org/atomic-desktops/)\n- Universal Blue: https://universal-blue.org)\n").
			WithObject(
				dag.TypeDef().WithObject("Atomic", TypeDefWithObjectOpts{Description: "Atomic represents the Dagger module type"}).
					WithFunction(
						dag.Function("Container",
							dag.TypeDef().WithObject("Container")).
							WithDescription("Container returns a Fedora Atomic container as a dagger.Container object")).
					WithFunction(
						dag.Function("Publish",
							dag.TypeDef().WithListOf(dag.TypeDef().WithKind(StringKind))).
							WithDescription("Publish build and publish the Fedora atomic container image").
							WithArg("registry", dag.TypeDef().WithKind(StringKind), FunctionWithArgOpts{Description: "registry url, e.g. ghcr.io"}).
							WithArg("imageName", dag.TypeDef().WithKind(StringKind), FunctionWithArgOpts{Description: "name of the image"}).
							WithArg("additionalTags", dag.TypeDef().WithListOf(dag.TypeDef().WithKind(StringKind)).WithOptional(true), FunctionWithArgOpts{Description: "additional tags to publish in addition to the default tags\ndefault tags will be included unless skipDefaultTags is set:\n [majorVersion, majorVersion-date, date]"}).
							WithArg("username", dag.TypeDef().WithKind(StringKind), FunctionWithArgOpts{Description: "registry username\nalso used as the registry namespace"}).
							WithArg("secret", dag.TypeDef().WithObject("Secret").WithOptional(true), FunctionWithArgOpts{Description: "registry auth password/secret"}).
							WithArg("skipSigningConfig", dag.TypeDef().WithKind(BooleanKind).WithOptional(true), FunctionWithArgOpts{Description: "skip opinionated ublue-way of setting up signing config\n  note: if basing off of ublue, this is already setup,\n        but not for the source image", DefaultValue: JSON("false")}).
							WithArg("skipRegistryNamespace", dag.TypeDef().WithKind(BooleanKind).WithOptional(true), FunctionWithArgOpts{Description: "skip namespacing registry with username\n  example:\n    registry=ghcr.io username=foo\n    default: => ghcr.io/foo/image\n    skip:    => ghcr.io/image", DefaultValue: JSON("false")}).
							WithArg("skipDefaultTags", dag.TypeDef().WithKind(BooleanKind).WithOptional(true), FunctionWithArgOpts{Description: "skip adding default tags", DefaultValue: JSON("false")})).
					WithFunction(
						dag.Function("PublishAndSign",
							dag.TypeDef().WithListOf(dag.TypeDef().WithKind(StringKind))).
							WithDescription("PublishAndSign build, publish, and sign (via cosign)\nthe Fedora container image").
							WithArg("registry", dag.TypeDef().WithKind(StringKind), FunctionWithArgOpts{Description: "registry url, e.g. ghcr.io"}).
							WithArg("imageName", dag.TypeDef().WithKind(StringKind), FunctionWithArgOpts{Description: "name of the image"}).
							WithArg("additionalTags", dag.TypeDef().WithListOf(dag.TypeDef().WithKind(StringKind)).WithOptional(true), FunctionWithArgOpts{Description: "additional tags to publish in addition to the default tags\ndefault tags will be included unless skipDefaultTags is set:\n [majorVersion, majorVersion-date, date]"}).
							WithArg("username", dag.TypeDef().WithKind(StringKind), FunctionWithArgOpts{Description: "registry username\nalso used as the registry namespace"}).
							WithArg("secret", dag.TypeDef().WithObject("Secret").WithOptional(true), FunctionWithArgOpts{Description: "registry auth password/secret"}).
							WithArg("skipSigningConfig", dag.TypeDef().WithKind(BooleanKind).WithOptional(true), FunctionWithArgOpts{Description: "skip opinionated ublue-way of setting up signing config\n  note: if basing off of ublue, this is already setup,\n        but not for the source image", DefaultValue: JSON("false")}).
							WithArg("skipRegistryNamespace", dag.TypeDef().WithKind(BooleanKind).WithOptional(true), FunctionWithArgOpts{Description: "skip namespacing registry with username\n  example:\n    registry=ghcr.io username=foo\n    default: => ghcr.io/foo/image\n    skip:    => ghcr.io/image", DefaultValue: JSON("false")}).
							WithArg("skipDefaultTags", dag.TypeDef().WithKind(BooleanKind).WithOptional(true), FunctionWithArgOpts{Description: "skip adding default tags", DefaultValue: JSON("false")}).
							WithArg("cosignPrivateKey", dag.TypeDef().WithObject("Secret"), FunctionWithArgOpts{Description: "Cosign private key"}).
							WithArg("cosignPassword", dag.TypeDef().WithObject("Secret"), FunctionWithArgOpts{Description: "Cosign password"}).
							WithArg("dockerConfig", dag.TypeDef().WithObject("File").WithOptional(true), FunctionWithArgOpts{Description: "Docker config"}).
							WithArg("cosignImage", dag.TypeDef().WithKind(StringKind).WithOptional(true).WithOptional(true), FunctionWithArgOpts{Description: "Cosign container image to be used to sign the digests", DefaultValue: JSON("\"chainguard/cosign:latest\"")}).
							WithArg("cosignUser", dag.TypeDef().WithKind(StringKind).WithOptional(true).WithOptional(true), FunctionWithArgOpts{Description: "Cosign container image user", DefaultValue: JSON("\"nonroot\"")})).
					WithField("Source", dag.TypeDef().WithObject("Directory")).
					WithField("Registry", dag.TypeDef().WithKind(StringKind), TypeDefWithFieldOpts{Description: "Source container image"}).
					WithField("Org", dag.TypeDef().WithKind(StringKind)).
					WithField("Tag", dag.TypeDef().WithKind(StringKind)).
					WithField("Variant", dag.TypeDef().WithKind(StringKind)).
					WithField("Suffix", dag.TypeDef().WithKind(StringKind).WithOptional(true)).
					WithField("Digests", dag.TypeDef().WithListOf(dag.TypeDef().WithKind(StringKind)), TypeDefWithFieldOpts{Description: "Generated atomic container image"}).
					WithField("Labels", dag.TypeDef().WithListOf(dag.TypeDef().WithKind(StringKind))).
					WithField("Tags", dag.TypeDef().WithListOf(dag.TypeDef().WithKind(StringKind)), TypeDefWithFieldOpts{Description: "MajorVersion *string\nDate string"}).
					WithField("ReleaseVersion", dag.TypeDef().WithKind(StringKind)).
					WithField("SkipDefaultLabels", dag.TypeDef().WithKind(BooleanKind), TypeDefWithFieldOpts{Description: "Flags"}).
					WithConstructor(
						dag.Function("New",
							dag.TypeDef().WithObject("Atomic")).
							WithArg("source", dag.TypeDef().WithObject("Directory"), FunctionWithArgOpts{Description: "Git repository root directory\nreferenced by Atomic.fedoraAtomic to determine the path to local files"}).
							WithArg("registry", dag.TypeDef().WithKind(StringKind).WithOptional(true), FunctionWithArgOpts{Description: "Container registry", DefaultValue: JSON("\"quay.io\"")}).
							WithArg("org", dag.TypeDef().WithKind(StringKind).WithOptional(true), FunctionWithArgOpts{Description: "Container registry organization", DefaultValue: JSON("\"fedora-ostree-desktops\"")}).
							WithArg("variant", dag.TypeDef().WithKind(StringKind).WithOptional(true), FunctionWithArgOpts{Description: "Atomic variant", DefaultValue: JSON("\"silverblue\"")}).
							WithArg("suffix", dag.TypeDef().WithKind(StringKind).WithOptional(true).WithOptional(true), FunctionWithArgOpts{Description: "Variant suffix string\ne.g. main (as related to ublue-os images)"}).
							WithArg("tag", dag.TypeDef().WithKind(StringKind).WithOptional(true), FunctionWithArgOpts{Description: "Tag or major release version", DefaultValue: JSON("\"40\"")}).
							WithArg("additionalLabels", dag.TypeDef().WithListOf(dag.TypeDef().WithKind(StringKind)).WithOptional(true), FunctionWithArgOpts{Description: "Labels to be applied to the generated container image in addition\nto the default labels"}).
							WithArg("skipDefaultLabels", dag.TypeDef().WithKind(BooleanKind).WithOptional(true), FunctionWithArgOpts{Description: "Optionally skip default labels", DefaultValue: JSON("false")}))), nil
	default:
		return nil, fmt.Errorf("unknown object %s", parentName)
	}
}
